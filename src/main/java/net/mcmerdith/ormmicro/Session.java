package net.mcmerdith.ormmicro;

import net.mcmerdith.ormmicro.modeling.MappedSqlModel;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class Session implements AutoCloseable {
    private final SessionFactory sessionFactory;

    private final Connection connection;

    private final ModelManager modelManager;

    private boolean transaction = false;

    public Session(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;

        modelManager = sessionFactory.getModelManager();
        try {
            connection = sessionFactory.getDataSource().getConnection();
        } catch (Exception e) {
            throw new RuntimeException("Could not create session, failed to connect to database!", e);
        }
    }

    /**
     * Direct access to this sessions JDBC connection
     * @return The connection used by this session
     */
    public Connection getConnection() {
        return connection;
    }

    /**
     * Begin a new transaction on the database
     * <p>If this session is already in a transaction, the existing transaction is committed before beginning</p>
     */
    public void beginTransaction() {
        if (transaction) commitTransaction();

        try {
            connection.setAutoCommit(false);
            transaction = true;
        } catch (Exception e) {
            throw new RuntimeException("Failed to start transaction!", e);
        }
    }

    /**
     * Commit the existing transaction
     * <p>If this session is not in a transaction this call is a no-op</p>
     */
    public void commitTransaction() {
        if (!transaction) return;

        try {
            connection.commit();
            connection.setAutoCommit(true);
            transaction = false;
        } catch (Exception e) {
            throw new RuntimeException("Failed to commit transaction!", e);
        }
    }

    /**
     * Rollback the existing transaction
     * <p>If this session is not in a transaction this call is a no-op</p>
     */
    public void rollbackTransaction() {
        if (!transaction) return;

        try {
            connection.rollback();
            connection.setAutoCommit(true);
            transaction = false;
        } catch (Exception e) {
            throw new RuntimeException("Failed to rollback transaction!", e);
        }
    }

    public void executeSql(String sql) throws SQLException {
        connection.createStatement().execute(sql);
    }

    public ResultSet executeSqlQuery(String sql) throws SQLException {
        return connection.createStatement().executeQuery(sql);
    }

    public int executeSqlUpdate(String sql) throws SQLException {
        return connection.createStatement().executeUpdate(sql);
    }

    public Statement executeSqlUpdate(String sql, String[] autoGeneratedNames) throws SQLException {
        Statement s = connection.createStatement();
        s.executeUpdate(sql, autoGeneratedNames);
        return s;
    }

    public Statement executeSqlUpdate(String sql, int[] autoGeneratedIndexes) throws SQLException {
        Statement s = connection.createStatement();
        s.executeUpdate(sql, autoGeneratedIndexes);
        return s;
    }

    public Statement executeSqlUpdate(String sql, boolean autoGenerated) throws SQLException {
        Statement s = connection.createStatement();
        s.executeUpdate(sql, autoGenerated ? Statement.RETURN_GENERATED_KEYS : Statement.NO_GENERATED_KEYS);
        return s;
    }

    public void save(Object o) {
        MappedSqlModel<?> mappedModel = sessionFactory.getModelManager().mapObject(o);

        if (sessionFactory.getPersistenceContext().isTracking(mappedModel)) {
            // We will be doing an "update" query
            update(mappedModel);
            return;
        }


    }

    private void update(MappedSqlModel<?> model) {

    }

    public void remove(Object o) {
        modelManager.getModel(o.getClass());
    }

    @Override
    public void close() throws SQLException {
        if (transaction) commitTransaction();
        connection.close();
    }
}
